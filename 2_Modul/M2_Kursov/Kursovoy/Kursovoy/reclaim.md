Добрый день, Сергей! Задание выполнено, ставлю зачёт! Мои комментарии:

В программе много классов, поэтому лучше использовать систему сборки CMake для приложения и библиотеки. Сейчас за это отвечает Visual Studio, и код привязан к IDE, а CMake сделает сборку для любой IDE.

Такие данные обычно скрывают внутри классов, потому что они не изменяются в процессе работы:

camel.set_move(10,30,5,8);
camelfast.set_move(40,10,5,6.5,8);
kentavr.set_move(15,8,2);
boots.set_move(6,60,10,5);
eagle.set_move(8,6);
carpet.set_move(10,3,10,5);
broom.set_move(20);
например, можно инициализировать их в списке инициализации полей в конструкторе класса.

Не увидел ни одного деструктора, хотя бы как = default;, а так же не забывайте, что конструкторы по умолчанию всё ещё есть, пока Вы не пометите их как = delete;

Get-методы обычно делают так:

const std::string& Kentavr::get_name() const
{
  return name;
}
быстрее будет вернуть константную ссылку, а второй const не позволит делать изменения в полях класса. Но для типов данных, которые <= double лучше копировать переменную:

int Kentavr::get_type() const
{
  return type;
}
Всегда проверяйте на 0 перед делением, в C++ это неотлавлимаемая ошибка и от ОС будет получено segmentation fault
t = distance_parts * (time_move + time_out1) + distance_ostatok / speed_move;
Советую в будущем почитать правила к стилю написания кода на C++ от Google, чтобы сделать его более чистым и читаемым - в командных проектах это очень важно.

В этом задании идеально было бы сделать класс Transport абстрактным с чисто виртуальными функциями.
Пример - metanit.com...l/5.12.php
Это позволит работать с несколькими наследниками через родителя:

std::vector<Transport*> transports = { new Camel(), new SpeedBoots(), new Caper(), … };
std::vector<AirTransport*> transports = { new SpeedBoots(), new Caper(), … };
std::vector<GroundTransport*> transports = { new Camel(), … };
Это примеры использования полиморфизма. B абстракция запретит использование Transport* transport = new Transport();. Теперь можно пройтись в цикле по каждому ТС и через переопределенные чисто виртуальные методы получить необходимые данные о классе.

Почитайте про форматирование строк, например, про std::format, чтобы в будущем удобнее формировать сложные строки:

std::cout << n << ". " << tr_arr[i]->get_name() << ". Время: " << tr_arr[i]->comp() << std::endl;

std::cout << std::format("{}. {}. Время: {}", n, tr_arr[i]->get_name(), tr_arr[i]->comp()) << std::endl;
Можно обойтись без goto оператора, если вынести все данные гонки в отдельный класс из main и просто пересоздавать объект класса в цикле, потому что goto делает код плохо читаемым.
Желаю удачи в дальнейшем обучении! Надеюсь мои комментарии помогут Вам в будущем)